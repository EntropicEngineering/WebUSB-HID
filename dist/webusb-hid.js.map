{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 6b66d538a9b76ab7aa16","webpack:///./src/webUSB_HID.js","webpack:///external {\"commonjs\":\"binary-parser\",\"commonjs2\":\"binary-parser\",\"amd\":\"binary-parser\",\"root\":\"_\"}"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;AC7DA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,iBAAiB;AACjC;;AAEA,kDAAkD,QAAQ;;AAE1D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO;AAChE;AACA;AACA;AACA;AACA;AACA;;;;;;;ACzGA,+C","file":"webusb-hid.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"binary-parser\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"binary-parser\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"webUSB_HID\"] = factory(require(\"binary-parser\"));\n\telse\n\t\troot[\"webUSB_HID\"] = factory(root[\"_\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6b66d538a9b76ab7aa16","/**\n * Created by riggs on 2017/9/1\n *\n * USB HID utility for WebUSB.\n */\n\nimport Parser from 'binary-parser';\n\n/* Utility Functions */\nfunction hex(buffer) {\n  Array.from(new Uint8Array(buffer), arg => \"0x\" + arg.toString(16).padStart(2, \"0\")).join(\", \")\n}\n\nlet version = new Parser()\n  .endianness('little')\n  .uint8('major')\n  .bit4('minor')\n  .bit4('patch');\n\nfunction decode_BCD(bcd_word) {\n  let major = Math.floor(bcd_word / 256);\n  let minor = Math.floor((bcd_word % 256) / 16);\n  let patch = (bcd_word % 256) % 16;\n  return [major, minor, patch];\n}\n\nexport async function connect(...filters) {\n  if (filters.length === 0) {\n    filters = [{vendorId: 0x03eb}]\n  }\n\n  let device = await navigator.usb.requestDevice({filters});\n\n  await device.open();\n  if (device.configuration === null)\n    await device.selectConfiguration(0);\n  await device.claimInterface(0);\n\n  return device;\n}\n\nconst HID_Class_Descriptors = {\n  HID: 0x21,\n  Report: 0x22,\n  Physical: 0x23,\n};\n\nasync function get_HID_class_descriptor(device, type, index, length, interface_id = 0) {\n  /* TODO: Error handling */\n  let result = await device.controlTransferIn({\n    requestType: \"standard\",\n    recipient: \"interface\",\n    request: /* GET_DESCRIPTOR */ 0x06,\n    value: type * 256 + index,\n    index: interface_id\n  }, length);\n  return result.data;\n}\n\nasync function get_HID_descriptor(device, interface_id = 0) {\n  let length = 9;\n  let data = await get_HID_class_descriptor(device, HID_Class_Descriptors.HID, 0, min_length, interface_id);\n\n  let returned_length = data.getUint8(0);\n\n  if (length < returned_length) {  /* Unlikely, but possible to have additional descriptors. */\n    length = returned_length;\n    data = await get_HID_class_descriptor(device, HID_Class_Descriptors.HID, 0, length, interface_id);\n  }\n\n  if (data.byteLength < length) {\n    throw Error(\"Invalid HID descriptor length: \" + hex(data.buffer));\n  }\n\n  return data;\n}\n\nfunction parse_HID_descriptor(data_view) {\n  const descriptor = {\n    length: null,\n    type: null,\n    version: [null, null, null],\n    country_code: null,\n    count: null,\n    descriptors: []\n  };\n  descriptor.length = data_view.getUint8(0);\n  descriptor.type = data_view.getUint8(1);\n  if (descriptor.type !== HID_Class_Descriptors.HID) {\n    throw Error(\"Invalid HID bDescriptorType at byte 1: \" + hex(data.buffer));\n  }\n  descriptor.version = decode_BCD(data_view.getUint16(2, true));\n  descriptor.country_code = data_view.getUint8(4);\n  /* TODO: Care about country code */\n  descriptor.count = data_view.getUint8(5);\n  let offset = 6;\n  while (offset < descriptor.length) {\n    let type = data_view.getUint8(offset);\n    if (!(type in HID_Class_Descriptors)) {\n      throw Error(\"Invalid HID bDescriptorType at byte `{offset}`: \" + hex(data.buffer));\n    }\n    let length = data_view.getUint16(offset + 1, true);\n    descriptor.descriptors.push([])\n  }\n  return descriptor;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/webUSB_HID.js\n// module id = 0\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"binary-parser\",\"commonjs2\":\"binary-parser\",\"amd\":\"binary-parser\",\"root\":\"_\"}\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}